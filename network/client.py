import socket
import time
from threading import Thread

import nacl.secret
import nacl.signing
import nacl.utils
from nacl.encoding import HexEncoder
from nacl.public import Box, PublicKey

from network.socket_protocol import send_message, receive_message, generate_keys, ConnectionManager
from utils.file import File, file_from_json, file_to_json, read_certificate
from utils.merkle import get_top_hash


class Client(ConnectionManager):
    _latest_top_hash = None

    def __init__(self):
        super().__init__()
        self.socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

        self.certificate = read_certificate('client_cert.txt')
        self.server_certificate = read_certificate('server_cert.txt')

    # TODO: Remove temporary threading solution
    def start(self):
        t = Thread(target=self.run)
        t.start()

    def run(self):
        self.connected = self.connect_to_host('localhost', 12317)
        time.sleep(0.5)
        self.setup_secure_channel()
        self.send_bytes(bytes('Hej jag Ã¤r hemlig data.', encoding='utf-8'))

        self.send_file(File(0, 'Secret file #0'))
        self.send_file(File(5, 'Secret file #5'))
        print('Client: Received ', self.receive_file().__dict__)
        time.sleep(0.5)
        self.send_file(File(2, 'Secret file #2'))
        print('Client: Received ', self.receive_file().__dict__)

    # TODO: Make use of Certificate Authorities?
    def connect_to_host(self, host, port):
        self.socket.connect((host, port))
        print('Client: Server connection established.')

        # Send our verification hex
        send_message(self.socket, self.verify_key_hex)
        # Send our signed certificate
        signed = self._sign_data(bytes(self.certificate, encoding='utf-8'))
        send_message(self.socket, signed)

        # Receive the server's verification hex
        server_key_hex = receive_message(self.socket)
        if not server_key_hex:
            self.disconnect()
            return False
        self._connection_verify_key = nacl.signing.VerifyKey(server_key_hex, encoder=HexEncoder)

        # Verify that both the server certificate and verification key arrived unchanged
        server_certificate = receive_message(self.socket)
        server_certificate = self._verify_sender(server_certificate)
        if not server_certificate:
            self.disconnect()
            print('Client: Server certificate or key tampered with.')
            return False

        server_certificate = server_certificate.decode('utf-8')
        if server_certificate != self.server_certificate:
            self.disconnect()
            print('Client: Server certificate invalid.')
            return False

        return True

    def setup_secure_channel(self):
        if not self.connected:
            return

        # Generate our private / public key pair
        private_key, public_key = generate_keys()
        public_key = public_key.encode(encoder=HexEncoder)
        print('Client: Keys generated.')

        # Send our public key to the server
        send_message(self.socket, self._sign_data(public_key))
        print('Client: Public key sent.')

        # Receive the server's public key
        server_public_key = receive_message(self.socket)
        server_public_key = self._verify_sender(server_public_key)
        if not server_public_key:
            return False
        server_public_key = PublicKey(server_public_key, encoder=HexEncoder)
        print('Client: Server public key received.')

        # Receive the secret key generated by the server
        box = Box(private_key, server_public_key)
        secret_key = receive_message(self.socket)
        secret_key = self._verify_sender(secret_key)
        if not secret_key:
            return False
        print('Client: Secret key received.')

        # Setup symmetric encryption using the secret key
        secret_key = box.decrypt(secret_key)
        self._set_secret_key(secret_key)
        return True

    def send_file(self, file):
        if not self.connected:
            return False

        file_json = file_to_json(file)
        self.send_bytes(bytes(file_json, encoding='utf-8'))
        hash_structure = self.receive_bytes()
        if not hash_structure:
            return False

        self._latest_top_hash = get_top_hash(hash_structure, file)
        print('Client: Calculated top hash:', self._latest_top_hash)
        return True

    def receive_file(self):
        if not self.connected:
            return None

        file_json = self.receive_bytes()
        if not file_json:
            return None
        file = file_from_json(file_json.decode('utf-8'))
        hash_structure = self.receive_bytes()
        if not hash_structure:
            return None
        if self._latest_top_hash != get_top_hash(hash_structure, file):
            return None

        return file
