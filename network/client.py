import socket
import ssl

import nacl.secret
import nacl.signing
import nacl.utils
from nacl.encoding import HexEncoder
from nacl.public import Box, PublicKey

from network.request import Request, request_to_json
from network.socket_protocol import send_message, receive_message, ConnectionManager
from utils.crypto import generate_keys, sign, verify_sender
from utils.file import File, file_from_json, file_to_json, read_certificate
from utils.merkle import get_root_hash


class Client(ConnectionManager):
    _latest_top_hash = None

    def __init__(self, use_default_ssl=False):
        super().__init__(use_default_ssl)
        self.socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

        self.certificate = read_certificate('client_cert.txt')
        self.server_certificate = read_certificate('server_cert.txt')

    def start(self):
        self.connected = self.connect_to_host('localhost', 12317)
        if not self.connected:
            return
        self.setup_secure_channel()

    def connect_to_host(self, host, port):
        self.socket.connect((host, port))
        print('Client: Server connection established.')

        if self.default_ssl:
            context = ssl.SSLContext(ssl.PROTOCOL_TLSv1_2)
            context.verify_mode = ssl.CERT_REQUIRED
            context.load_verify_locations('certificates/server.pem')
            context.load_cert_chain(certfile='certificates/client.pem', keyfile='certificates/client.key')

            if ssl.HAS_SNI:
                self.socket = context.wrap_socket(self.socket, server_side=False, server_hostname=host)
            else:
                self.socket = context.wrap_socket(self.socket, server_side=False)

            cert = self.socket.getpeercert()
            if not cert or ('commonName', 'Jupiter') not in cert['subject'][5]:
                self.disconnect()
                return False

            return True

        # Send our verification hex
        send_message(self.socket, self.verify_key_hex)
        # Send our signed certificate
        signed = sign(self._signing_key, bytes(self.certificate, encoding='utf-8'))
        send_message(self.socket, signed)

        # Receive the server's verification hex
        server_key_hex = receive_message(self.socket)
        if not server_key_hex:
            self.disconnect()
            return False
        self._connection_verify_key = nacl.signing.VerifyKey(server_key_hex, encoder=HexEncoder)

        # Verify that both the server certificate and verification key arrived unchanged
        server_certificate = receive_message(self.socket)
        server_certificate = verify_sender(self._connection_verify_key, server_certificate)
        if not server_certificate:
            self.disconnect()
            print('Client: Server certificate or key tampered with.')
            return False

        server_certificate = server_certificate.decode('utf-8')
        if server_certificate != self.server_certificate:
            self.disconnect()
            print('Client: Server certificate invalid.')
            return False

        return True

    def setup_secure_channel(self):
        if not self.connected or self.default_ssl:
            return False

        # Generate our private / public key pair
        private_key, public_key = generate_keys()
        public_key = public_key.encode(encoder=HexEncoder)
        print('Client: Keys generated.')

        # Send our public key to the server
        send_message(self.socket, sign(self._signing_key, public_key))
        print('Client: Public key sent.')

        # Receive the server's public key
        server_public_key = receive_message(self.socket)
        server_public_key = verify_sender(self._connection_verify_key, server_public_key)
        if not server_public_key:
            return False
        server_public_key = PublicKey(server_public_key, encoder=HexEncoder)
        print('Client: Server public key received.')

        # Receive the secret key generated by the server
        box = Box(private_key, server_public_key)
        secret_key = receive_message(self.socket)
        secret_key = verify_sender(self._connection_verify_key, secret_key)
        if not secret_key:
            return False
        print('Client: Secret key received.')

        # Setup symmetric encryption using the secret key
        secret_key = box.decrypt(secret_key)
        self._set_secret_key(secret_key)
        return True

    def send_file(self, file):
        if not self.connected:
            return False

        file_json = file_to_json(file)
        request = Request('send_file', file_json)
        request_json = request_to_json(request)
        self.send_bytes(bytes(request_json, encoding='utf-8'))

        hash_structure = self.receive_bytes()
        if not hash_structure or hash_structure.decode('utf-8') == 'error':
            return False

        self._latest_top_hash = get_root_hash(hash_structure, file)
        print('Client: Calculated top hash:', self._latest_top_hash)
        return True

    def request_file(self, file_id):
        if not self.connected:
            return None
        request = Request('get_file', file_id)
        request_json = request_to_json(request)
        self.send_bytes(bytes(request_json, encoding='utf-8'))
        return self.receive_file()

    def receive_file(self):
        if not self.connected:
            return None

        file_json = self.receive_bytes()
        if not file_json or file_json.decode('utf-8') == 'error':
            return None
        file = file_from_json(file_json.decode('utf-8'))
        hash_structure = self.receive_bytes()
        if not hash_structure:
            return None
        if self._latest_top_hash != get_root_hash(hash_structure, file):
            return None

        return file


if __name__ == '__main__':
    client = Client(False)
    client.start()

    print('Ready to serve:')
    while client.connected:
        cmd = input()
        tokens = cmd.split(' ')
        if len(tokens) < 2:
            client.disconnect()
        if tokens[0] == 'send':
            fid = int(tokens[1])
            data = ' '.join(tokens[2:])
            client.send_file(File(fid, data))
        elif tokens[0] == 'get':
            fid = int(tokens[1])
            result = client.request_file(fid)
            print(result.data if result else 'No data received.')
    print('Disconnected')
